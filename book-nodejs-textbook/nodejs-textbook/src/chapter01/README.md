# Chapter01. 노드 시작하기

## 📌 1.1 핵심 개념 이해하기

> Node.js 는 Chrome V8 Javascript 엔진으로 빌드된 Javascript 런타임입니다.

- 서버라는 말이 없는 이유는 노드가 서버만 실행할 수 있는 것이 아니기 때문입니다.

### ➕ 1.1.1 서버

- 서버는 네트워크를 통해 클라이언트에 정보나 서비스를 제공하는 컴퓨터 또는 프로그램을 말한다.
- 클라이언트란 요청을 보내는 주체로 브라우저일 수도 있고, 데스크톱 프로그램일 수도 있고, 모바일 앱일 수도 있고, 다른 서버에 요청을 보내는 서버일 수도 있습니다.

- 예를 들어, 모바일 앱을 설치하는 경우

  - 구글 플레이 스토어나 애플 앱스토어에서 원하는 앱을 고른 후 설치 버튼을 누르면 => 요청
  - 내려받기 => 응답
  - 앱 설치 파일은 이미 어딘가에 저장되어 있으므로 그곳에서 데이터를 받아와 모바일 기기에 설치할 수 있다.
  - 그 어딘가가 구글과 애플의 서버이고, 플레이 스토어와 앱스토어는 클라이언트 역할을 하는 것입니다.

- 노드는 자바스크립트 프로그램이 서버로서 가능하기 위한 도구를 제공하으로 서버 역할을 수행할 수 있습니다.

### ➕ 1.1.2 자바스크립트 런타임

> 노드는 자바스크립트 런타입입니다. 런타임은 특정 언어로 만든 프로그램들을 실행할 수 있는 환경을 뜻합니다.  
> 따라서, 노드는 자바스크립트 프로그램을 컴퓨터에서 실행할 수 있습니다.

- 기존에는 자바스크립트 프로그램을 웹 브라우저 위에서만 실행할 수 있었습니다. 브라우저는 자바스크립트 런타임을 내장하고 있으므로 자바스크립트 코드를 실행할 수 있습니다.

- 2008년 구글이 V8 엔진을 사용하여 크롬을 출시하였고, V8 엔진은 다른 자바스크립트 엔진과 달리 매우 빨랐습니다. 구글은 또한 오픈소스로 코드를 공개하였고, 속도 문제가 해결되자 라이언 달은 2009년 V8 엔진 기반의 노드 프로젝트를 시작하였습니다.

- 노드의 내부 구조

  ```
  [ Node.js Core Library ]
    [ Node.js Bindings ]
    [ V8 ]    [ libuv ]
      ||         ||
    오픈 소스     비동기 I/O

    [ 자바스크립트 엔진 ]
  ```

  - 노드는 V8 과 더불어 libuv라는 라이브러리를 사용합니다.
  - V8과 libuv는 C와 C++로 구현되어 있습니다.
  - libuv 라이브러리는 노드의 특성인 이벤트기반, 논 블로킹 I/O 모델을 구현하고 있습니다.

### ➕ 1.1.3 이벤트 기반

> 이벤트 기반(event-driven) 이란 이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식을 의미합니다.

- 이벤트 기반 시스템에서는 특정 이벤트가 발생할 때 무엇을 할지 미리 등록해두어야 합니다. 이를 이벤트 리스너(event listener) 에 콜백(callback) 함수를 등록한다고 표현합니다.

  ```
  [시스템]  =========>  [이벤트 리스너]
          2.이벤트 발생   1.이벤트 리스너에
                          콜백 함수 등록
          <=========
        3.등록된 콜백 함수 호출
  ```

- 여러 이벤트가 동시에 발생했을 때 어떤 순서로 콜백 함수를 호출할지를 이벤트 루프가 판단합니다.
- 노드는 자바스크립트 코드의 맨 위부터 한 줄씩 실행합니다. 함수 호출 부분을 발견했다면 호출한 함수를 호출 스택(call stack)에 넣습니다.

  ```javascript
  function first() {
    second()
    console.log('첫번째')
  }
  function second() {
    third()
    console.log('두번째')
  }
  function third() {
    console.log('세번째')
  }
  first()
  ```

  ```
  ▲▲▲▲▲▲▲  [ third() ]  ▼▼▼▼▼▼▼▼
  이 순서로  [ second() ] 이 순서로
   쌓이고    [ first() ]  실행됨
          [ anonymous ]
  ```

  - anonymous 함수는 처음 실행 시의 전역 컨텍스트(global context) 를 의미합니다.
  - 컨텍스트는 함수가 호출되었을 때 생성되는 환경을 의미합니다.

- **이벤트 루프**
  - 이벤트 발생 시 호출할 콜백 함수들을 관리하고, 호출된 콜백 함수의 실행 순서를 결정하는 역할을 담당합니다. 노드가 종료될 때까지 이벤트 처리를 위한 작업을 반복하므로 루프(loop) 라고 부릅니다.
- **백그라운드**
  - setTimeout 같은 타이머나 이벤트 리스너들이 대기하는 곳입니다. 자바스크립트가 아닌 다른 언어로 작성된 프로그램이라고 봐도 됩니다. 여러 작업이 동시에 실행될 수 있습니다.
- **태스크 큐**

  - 이벤트 발생 후, 백그라운드에서는 태스크 큐로 타이머나 이벤트 리스너의 콜백함수를 보냅니다. 정해진 순서대로 콜백들이 줄을 서 있으므로 콜백 큐라고도 부릅니다. 콜백들은 보통 완료된 순서대로 줄을 서 있지만 특정한 경우에는 순서가 바뀌기도 합니다.

  ```
  1. 호출 스택에 쌓임
  2. setTimeout 실행 시 콜백 run은 백그라운드로 보냄
  3. 백그라운드에서 3초 후 태스크 큐로 보냄

    <호출 스택>   ====>    <백그라운드>    ====>   <태스크 큐>

  [setTimeout()]       [타이머run 3초]            [run]
  [anonymous]

  4. 호출 스택 실행이 끝나 비워지면
  5. 이벤트 루프가 태스크 큐의 콜백을 호출 스택으로 올림

    <호출 스택>   ====>    <백그라운드>    ====>   <태스크 큐>

                                                [run]

  6. run이 호출 스택에서 실행되고 비워짐
  7. 이벤트 루프는 태스크 큐에 콜백이 들어올 때까지 대기

    <호출 스택>   ====>    <백그라운드>    ====>   <태스크 큐>

    [run]

  만약, 호출 스택에 함수들이 너무 많이 들어 있으면 3초가 지난 후에도 run 함수가 실행되지 않을 수 있습니다. 이벤트 루프는 호출 스택이 비어 있을 때만 태스크 큐에 있는 run 함수를 호출 스택으로 가져오기 때문입니다. 이것이 setTimeout의 시간이 정확하지 않을 수도 있는 이유입니다.
  ```

### ➕ 1.1.4 논 블로킹 I/O

- 작업에는 두 가지 종류가 있는데, 동시에 실행될 수 있는 작업과 동시에 실행될 수 없는 작업입니다.
- 기본적으로 자바스크립트 코드는 동시에 실행될 수 없습니다. 하지만, 자바스크립트상에서 돌아가는 것이 아닌 I/O 작업 같은 것은 동시에 처리될 수 있습니다.

- I/O 는 입력(Input)/출력(Output) 을 의미합니다. 파일 시스템 접근이나 네트워크를 통한 요청 같은 작업이 I/O의 일종입니다.

> 논 블로킹이란 이전 작업이 완료될 때까지 대기하지 않고 다음 작업을 수행함을 뜻합니다. 반대로 블로킹은 이전 작업이 끝나야만 다음 작업을 수행하는 것을 의미합니다.

- 노드는 I/O 작업을 백그라운드로 넘겨 동시에 처리하곤 합니다. 따라서 동시에 처리될 수 있는 작업들은 최대한 묶어서 백그라운드로 넘겨야 시간을 절약할 수 있습니다.

```javascript
/**
 * 블로킹 방식의 코드
 **/
function longRunningTask() {
  // 오래 걸리는 작업
  console.log('작업 끝')
}

console.log('시작')
longRunningTask()
console.log('다음 작업')

// 결과
시작
작업 끝
다음 작업

/**
 * setTimeout 을 활용한 논 블로킹 방식의 코드
 */
console.log('시작')
setTimeout(longRunningTask(), 0)
console.log('다음 작업')

// 결과
시작
다음 작업
작업 끝
```

- 논 블로킹 방식으로 코드를 작성하더라도 코드가 전부 내가 작성한 것이라면 전체 소요 시간이 짧아지지는 않습니다. 나의 코드가 서로 동시에 실행되지 않기 때문입니다. 단지 실행 순서만 바뀔 뿐입니다.

- I/O 작업이 없다고 해서 논 블로킹의 의미가 없는 것은 아닙니다. 오래 걸리는 작업을 처리해야 하는 경우, 논 블로킹을 통해 실행 순서를 바꿔줌으로써 그 작업 때문에 간단한 작업들이 대기하는 상황을 막을 수 있다는 점에서 의의가 있습니다.

- 또한, 논 블로킹과 동시는 같은 의미가 아닙니다. 동시성은 동시 처리가 가능한 작업을 논 블로킹 처리해야 얻을 수 있습니다.

### ➕ 1.1.5 싱글 스레드

- 프로세스와 스레드의 차이

  - 프로세스는 운영체제에서 할당하는 작업의 단위입니다. 노드나 웹 브라우저 같은 프로그램은 개별적인 프로세스입니다. 프로세스 간에는 메모리 등의 자원을 공유하지 않습니다.
  - 스레드는 프로세스 내에서 실행되는 흐름의 단위입니다. 프로세스는 스레드를 여러 개 생성해 여러 작업을 동시에 처리할 수 있습니다. 스레드들은 부모 프로세스의 자원을 공유합니다. 같은 주소의 메모리에 접근 가능하므로 데이터를 공유할 수 있습니다.

- 노드를 실행하면 먼저 프로세스가 하나 생성됩니다. 그리고 그 프로세스에서 스레드들을 생성하는데, 이때 내부적으로 스레드를 여러 개 생성합니다.
- 그 중에서 여러분이 직접 제어할 수 있는 스레드는 하나뿐입니다. 그래서 흔히 노드가 싱글 스레드라고 여겨지는 것입니다.
- 하나의 스레드만 직접 조작할 수 있으므로 일손이 하나인 셈입니다. 요청이 많이 들어오면 한 번에 하나씩 요청을 처리합니다. 블로킹이 심하게 일어나는 작업을 처리하지만 않는다면 스레드 하나로도 충분합니다.
- 블로킹이 발생할 것 같은 경우에는 논 블로킹 방법으로 대기 시간을 최대한 줄입니다.

- 스레드풀과 워커 스레드
  - 노드가 싱글 스레드로 동작하지 않는 두 가지 경우가 있습니다.
  - 스레드 풀(Thread Pool)
    - 노드가 특정 동작을 수행할 때 스스로 멀티 스레드를 사용합니다.
    - 대표적인 예로, 암호화, 파일 입출력, 압축 등이 있습니다.
  - 워커 스레드(Worker Thread)
    - 노드 12버전에서 안정화된 기능으로 이제 노드에서도 멀티 스레드를 사용할 수 있게 되었습니다.
    - 직접 다수의 스레드를 다룰 수 있고, CPU 작업이 많은 경우 워커 스레드를 사용하면 됩니다.
- 멀티 스레드와 싱글 스레드 비교 예시

  - 싱글 스레드, 블로킹 방식

    - 한 음식점에 점원이 한명, 손님은 여러명
    - 점원 한 명이 주문을 받아 주방에 넘기고, 주방에서 요리가 나오면 손님에게 서빙
    - 그 후 다음 손님의 주문  
      ==> 다음 손님은 이전 손님의 요리가 나올 때까지 아무것도 못 하고 기다려야 함

  - 싱글 스레드, 논 블로킹 방식

    - 점원이 한 손님의 주문을 받고, 주방에 주문 내역을 넘긴 뒤 다음 손님의 주문을 받음  
      => 요리가 끝나기까지 기다리는 대신, 주문이 들어왔다는 사실만 주방에 계속 알려줌
    - 주방에서 요리가 완료되면 완료된 순서대로 손님에게 서빙
    - 요리의 특성에 따라 완료되는 순서가 다를 수 있으므로, 주문이 들어온 순서와 서빙하는 순서가 다를 수 있음.  
      ==> `노드가 채택하고 있는 방식`  
      점원은 한 명이지만 혼자서 많은 일을 처리할 수 있습니다.
      하지만, 그 점원 한 명이 아파서 쓰러지거나 하면 큰 문제가 생길 수 있고, 요리하는데 시간이 오래걸린다면(CPU를 많이 쓰는 작업) 주문이 많이 많이 들어왔을 경우 버거울 수 있습니다.

  - 멀티 스레드, 블로킹

    - 손님이 한 명이 올 때마다 점우너도 한 명씩 붙어 주문을 받고 서빙합니다.  
      ==> 손님 한 명당 점원도 한 명이면 서빙에 문제가 없고, 점원 한 명에게 문제가 생겨도 다른 점원으로 대체하면 됩니다. 하지만, 손님의 수가 늘어날수록 점원의 수도 늘어납니다. 손님 수가 줄어들었을때 일을 하지 않고 노는 점원이 생긴다면 문제가 됩니다. 또한 점원을 새로 고용하거나 기존 점원을 해고하는 데는 비용이 발생합니다.

  - 멀티 스레드, 논 블로킹
    - 멀티 스레드 방식으로 프로그래밍하는 것은 상당히 어려우므로 멀티 프로세싱 방식을 대신 사용합니다.
    - I/O 요청에는 멀티 프로세싱이 더 효율적이기도 합니다.

## 1.2 서버로서의 노드

### ➕ 장단점

- 노드는 기본적으로 싱글 스레드, 논 블로킹 모델을 사용하므로 노드 서버 또한 동일한 모델일 수 밖에 없습니다.
- 따라서, 노드 서버의 장단점은 싱글 스레드, 논 블로킹 모델의 장단점과 다르지 않습니다.

- 장점

  - 노드는 논 블로킹 방식으로 코드를 작성했다는 가정하에 libuv 라이브러리를 사용하여 I/O 작업을 논 블로킹 방식으로 처리합니다. 따라서 스레드 하나가 많은 수의 I/O 를 혼자서도 감당할 수 있습니다.
  - 개수는 많지만 크기는 작은 데이터를 실시간으로 주고받는데 적합합니다.
    - 네트워크나 데이터베이스, 디스크 작업 같은 I/O 에 특화되어 있기 때문입니다.
    - 실시간 채팅 애플리케이션이나 주식 차트, JSON 데이터를 제공하는 API서버가 노드를 많이 사용합니다.
  - 싱글 스레드 방식의 프로그래밍은 멀티 스레드 방식보다 상대적으로 쉬우므로 쉽게 입문할 수 있습니다.
  - 웹 서버가 내장되어 있어 입문자가 쉽게 접근할 수 있습니다.
    - 노드 외의 경우 Apache, NginX, IIS 처럼 별도의 웹 서버를 설치하는 경우가 많고, Tomcat같은 WAS를 추가로 설치하는 경우도 있습니다.
  - 가장 큰 장점은 언어로 자바스크립트를 사용한다는 것입니다.
    - 웹 브라우저도 자바스크립트를 사용하므로 서버까지 노드를 사용하면 하나의 언어로 웹 사이트를 개발할 수 있습니다.
    - 이로써 개발 생산성을 획기적으로 높였고, 생산성이 중요한 기업이 노드는 채택하는 이유가 되었습니다.
    - 요즘은 XML 대신 JSON을 사용해서 데이터를 주고받는데, JSON이 자바스크립트 형식이므로 노드에서느 쉽게 처리할 수 있습니다.

- 단점
  - 노드는 CPU 부하가 큰 작업에는 적합하지 않습니다. 코드가 CPU 연산을 많이 요구하면 스레드가 하나이기 때문에 혼자서 감당하기 어렵습니다.
  - 워커 스레드 기능의 안정화로 멀티 스레드 작업을 할 수 있지만, 프로그래밍이 어렵고 특히, 스레드가 작업을 나눠서 처리할 수 있게 직접 나누어주는 것이 그렇습니다. 또한, 멀티 스레드 프로그래밍을 하더라도 C, C++, Rust, Go 와 같은 언어에 비해 속도가 많이 느립니다.
    - 따라서, 멀티 스레드 기능이 있다고 하더라도 이미지나 비디오 처리, 혹은 대규모 데이터 처리처럼 CPU를 많이 사용하는 작업을 위한 서버로는 권장하지 않습니다.
    - 그럼에도 노드로 하고 싶다면, AWS Lambda 나 Google Cloud Functions 같은 서비스에서 노드로 CPU를 많이 사용하는 작업을 처리하는 것을 지원하므로 고려해봐야 합니다.
  - 싱글 스레드 방식으로 서버를 운영할 때는 하나뿐인 스레드가 에러로 인해 멈추지 않도록 잘 관리해야 합니다.
  - 서버 규모가 커지면 결국 NginX 등의 웹 서버를 노드 서버와 연결해야만 합니다.
  - 생산성은 매우 좋지만, Go처럼 비동기에 강점을 보이는 언어나 NginX 처럼 정적 파일 제공, 로드 밸런싱에 특화된 웹 서버에 비해서는 속도가 느립니다.
    - 극단적인 성능이 필요하지 않다면 이러한 단점은 노드의 생산성으로 어느 정도 극복할 수 있습니다.

## 1.3 서버 외의 노드

- 노드는 자바스크립트 런타임이므로 용도가 서버에만 한정되지 않습니다.
- 사용 범위가 점점 늘어나서 노드는 웹, 모바일, 데스크톱 애플리케이션 개발에도 사용되기 시작했습니다.
- 노드 기반 대표적인 웹 프레임워크로는 Angular, React, Vue 등이 있습니다.
- 모바일 개발 도구로는 React Native를 많이 사용합니다.
- 데스크톱 개발 도구로는 Electron 이 대표적입니다.

## 1.4 개발 환경 설정하기

- LTS와 Current 버전의 차이
  - LTS
    - 기업을 위해 3년간 지원하는 버전입니다. 짝수 버전만 LTS 버전이 될 수 있습니다. 서버를 안정적으로 운영해야 할 경우 선택합니다. 하지만 최신 기능을 사용하지 못할 수도 있습니다.
  - Current
    - 최신 기능을 담고 있는 버전입니다. 다소 실험적인 기능이 들어 있어 예기치 못한 에러가 발생할 수 있습니다. 서버에 신기능이 필요하거나 학습용으로 사용할 때 적합합니다.
    - 단, 짝수 버전은 나중에 LTS가 되므로 Current일 때부터 사용하는 것을 고려해볼 만합니다.
  - 홀수버전
    - 노드는 6개월마다 버전을 1씩 올립니다. 따라서 14버전 이전에 13버전도 있었습니다. 하지만 홀수 버전은 LTS를 지원하지 않으므로 14버전이 나오면서 13버전은 사라졌습니다. 나중에 15버전이 나오면 14버전이 LTS가 되고 15버전이 Current가 됩니다.
